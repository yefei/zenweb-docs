# 业务逻辑与依赖注入

zenweb 最核心的设计理念 `依赖注入` 功能，设计上参考了 `Spring` 方案并做了一些调整

## 定义一个最简单的业务类

```ts title="src/service/user_service.ts"
// 定义并导出类
export class UserService {
  getByUsername(username: string) {
    return "You name is: " + username;
  }
}
```

## 在控制器中使用业务类实例

```ts title="src/controller/user.ts"
export class UserController {
  @mapping()
  getByService(userService: UserService) { // 只需要在控制器方法参数中标识需要使用的类即可
    return userService.getByUsername("Bob");
  }
}
```

## 在业务类中注入业务类

```ts title="src/service/auth_service.ts"
import { inject } from "zenweb";
import { UserService } from "./user_service";

export class AuthService {
  // 使用 @inject 装饰器即可导入依赖类实例
  @inject userService: UserService;

  login(username: string) {
    return this.userService.getByUsername(username);
  }
}
```

## 作用域级别

类作用域是指一个类的实例所处的上下文生命周期

zenweb 注入类的作用域一个分为一下三种：

- `singleton`: 单例模式，对象只会初始化一次并一直存活在整个应用生命周期中
  - 此级别下对象不可注入 request 级别的对象
- `request`: 请求模式，当前请求中只会被初始化一次，同一个请求中上下文中共享同一个实例对象
  - 被标记为 request 作用域的对象不能注入到 singleton 中
- `prototype`: 原型模式，每次注入时都会被初始化，每一个注入对象都是新的
  - 因为每次都新建一个实例，通常情况下不使用
  - 任何级别都可以注入此级别的对象

:::tip 与 Spring 的区别
与 `Spring` 不同的是类的默认作用域级别为 `request`，而并非 `singleton`，
因为在 web 项目中这更常用，也避免错误的使用 `singleton` 造成共享变量污染。
:::

### 修改类的作用域

```ts title="src/service/db_service.ts"
import { scope } from "zenweb";

// 标记类为单例类型
@scope("singleton")
export class DbService {
  // 通常来说数据库连接只需要一次即可，避免每次请求都连接数据浪费资源
  conn = new DatabaseConnection();

  query(sql: string) {
    return this.conn.query(sql);
  }
}
```

## 在非业务类中取得类实例

我们知道在业务类中可以通过 `@inject` 来取得一个类的实例

如果在 `中间件` 中，这种非业务类的方法中如何获得一个类实例呢？

其实在 `Context` 上下文对象中存在一个 `injecter` 属性，可以通过他来取得需要的对象实例。

```ts
function someMiddleware(): Middleware {
  return async function (ctx, next) {
    // 注意这里一定要使用 await
    const someService = await ctx.injecter.getInstance(SomeService);
    // ...
    return next();
  }
}
```
